"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useTRenderEngine;

var _react = require("react");

var _transientRenderEngine = _interopRequireWildcard(require("@native-html/transient-render-engine"));

var _lookupRecord = _interopRequireDefault(require("../helpers/lookupRecord"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function useTRenderEngine(props) {
  const {
    allowedStyles,
    ignoredStyles,
    decodeEntities,
    baseStyle,
    classesStyles,
    tagsStyles,
    idsStyles,
    enableCSSInlineProcessing,
    enableUserAgentStyles,
    fallbackFonts,
    systemFonts,
    renderers = {},
    triggerTREInvalidationPropNames
  } = props;
  const isFontSupported = (0, _react.useMemo)(() => {
    const fontMap = {};
    systemFonts.forEach(font => {
      fontMap[font] = true;
    });
    return fontFamily => {
      if (fallbackFonts[fontFamily]) {
        return fallbackFonts[fontFamily];
      }

      return fontMap[fontFamily] || false;
    };
  }, [systemFonts, fallbackFonts]);
  const tbuilderDeps = (triggerTREInvalidationPropNames || []).map(key => props[key]);

  const customizeHTMLModels = defaultModels => {
    const additionalModels = {};
    const customRenderersKeys = Object.keys(renderers);

    if (!customRenderersKeys.length) {
      return defaultModels;
    }

    customRenderersKeys.forEach(key => {
      const renderer = renderers[key];

      if ((0, _lookupRecord.default)(defaultModels, key)) {
        if (renderer.model && defaultModels[key] !== renderer.model) {
          if (renderer.model instanceof _transientRenderEngine.HTMLElementModel) {
            additionalModels[key] = renderer.model;
          } else {
            additionalModels[key] = _transientRenderEngine.HTMLElementModel.fromCustomModel({ ...renderer.model,
              tagName: key
            });
          }
        } else if (!renderer.model && defaultModels[key].contentModel === _transientRenderEngine.HTMLContentModel.mixed) {
          __DEV__ && console.warn("You are defining a custom renderer for tag \"".concat(key, "\" which has a mixed content model.") + 'Be advised that this tag can be translated to TBlock, TText or Tphrasing nodes. ' + 'You must explicitly set the corresponding HTMLElementModel from "defaultHTMLElementModels" ' + 'as a static "model" field of your renderer to show you understand the constrains inherent to ' + 'those renderers.');
        }
      } else {
        if (renderer.model) {
          additionalModels[key] = _transientRenderEngine.HTMLElementModel.fromCustomModel({ ...renderer.model,
            tagName: key
          });
        } else {
          __DEV__ && console.error("You must provide a model in custom renderer for tag \"".concat(key, "\". Set the \"model\" static field ") + 'of your custom renderer.');
        }
      }
    });
    return { ...defaultModels,
      ...additionalModels
    };
  };

  return (0, _react.useMemo)(() => new _transientRenderEngine.default({
    customizeHTMLModels,
    cssProcessorConfig: {
      isFontSupported,
      inlinePropertiesBlacklist: ignoredStyles,
      inlinePropertiesWhitelist: allowedStyles
    },
    htmlParserOptions: {
      decodeEntities
    },
    stylesConfig: {
      baseStyle,
      enableCSSInlineProcessing,
      enableUserAgentStyles,
      classesStyles,
      idsStyles,
      tagsStyles
    }
  }), // eslint-disable-next-line react-hooks/exhaustive-deps
  [...tbuilderDeps, isFontSupported]);
}
//# sourceMappingURL=useTRenderEngine.js.map